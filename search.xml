<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Netty网络编程二：Netty概述以及入门案例</title>
      <link href="/2019/05/12/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BA%8C%EF%BC%9ANetty%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"/>
      <url>/2019/05/12/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BA%8C%EF%BC%9ANetty%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>本人写的Netty相关文章，全部基于版本4.1.33.Final</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1、概述2、入门案例</code></pre><h1 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h1><p>虽然原生的java给我们提供了非常强大NIO的功能，但是由于使用上的，众多网络编程上的问题，任然需要开发者自己开发维护，因为选择Netty这种基于原生NIO进行开发的框架来助于我们的开发。</p><h1 id="二：入门案例"><a href="#二：入门案例" class="headerlink" title="二：入门案例"></a>二：入门案例</h1><p>学任何框架都是从入门案例，netty也不例外，先搭建一个简单的服务端，客户端来理解Netty的便捷性。</p><p>需求：客户端连接服务端后，给服务端发送一条消息，服务端收到消息后，给客户端发送一条消息</p><p>服务端：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NettyServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span>(<span class="params"><span class="keyword">int</span> port</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// boss 是处理客户端连接的线程池</span></span><br><span class="line">        <span class="comment">// worker 是处理从客户端连接转发过来的IO数据的读写线程池</span></span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// ServerBootstrap 对外一个便利创建服务端，Builder建造者设计模式</span></span><br><span class="line">            ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">// 绑定线程池</span></span><br><span class="line">            sb.<span class="keyword">group</span>(boss,worker)</span><br><span class="line">                    <span class="comment">// 绑定channel 服务端绑定NioServerSocketChannel,此实现jdk的ServerSocketChannel</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 绑定服务端相关参数，可添加绑定多个参数</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>) <span class="comment">//指定此套接口排队的最大连接个数</span></span><br><span class="line">                    <span class="comment">// IO事件处理类，主要处理IO事件的读写</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span>(<span class="params">SocketChannel ch</span>) throws Exception</span> &#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">// 添加</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定端口，同步等待成功</span></span><br><span class="line">            ChannelFuture cf = sb.bind(port).sync();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"服务已启动.................监听端口："</span> + port);</span><br><span class="line">            <span class="comment">// 等待服务器监听端口关闭</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 优雅关闭线程资源</span></span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        NettyServer nettyServer = <span class="keyword">new</span> NettyServer(<span class="number">9090</span>);</span><br><span class="line">        nettyServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handler处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) msg;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.readableBytes()];</span><br><span class="line">        byteBuf.readBytes(buf);</span><br><span class="line">        String str = <span class="keyword">new</span> String(buf, <span class="string">"utf-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"收到信息 ： "</span> + str);</span><br><span class="line">        <span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">        ByteBuf writeBuf = Unpooled.copiedBuffer((<span class="string">"服务端发送的消息 ： "</span> + currentTimeMillis).getBytes());</span><br><span class="line">        ctx.write(writeBuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注意：此flush()方法是将消息发送队列中的消息写入到SocketChannel中发送给对方。</span></span><br><span class="line"><span class="comment">         * 从性能角度考虑，为了防止频繁地唤醒Selector进行消息发送，Netty的write()方法并不直接将消息写入SocketChannel中，</span></span><br><span class="line"><span class="comment">         * 调用write()方法只是把待发送的消息放到发送缓冲数组中，再通过调用flush()方法，将发送缓冲区中的消息全部写到SocketChannel中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"channelReadComplete............"</span>);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"消息异常.....exceptionCaught "</span>);</span><br><span class="line">        <span class="comment">// 当发送异常时，关闭ctx，是否和ctx相关联的句柄等资源</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户事件触发....    userEventTriggered"</span>);</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NettyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line">        NioEventLoopGroup <span class="keyword">group</span> = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.<span class="keyword">group</span>(<span class="keyword">group</span>).channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY,<span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span>(<span class="params">SocketChannel ch</span>) throws Exception</span> &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 异步连接服务端</span></span><br><span class="line">            ChannelFuture f = b.connect(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>)).sync();</span><br><span class="line">            <span class="comment">// 等待关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//优雅退出，是否线程池资源</span></span><br><span class="line">            <span class="keyword">group</span>.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端handler处理器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 当客户端与服务端链路建立成功后调用此方法</span></span><br><span class="line">        System.out.println(<span class="string">"channelActive..."</span>);</span><br><span class="line">        ByteBuf message = Unpooled.copiedBuffer(<span class="string">"fangyouyun client msg"</span>.getBytes());</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelRead......"</span>);</span><br><span class="line">        ByteBuf returnMsg = (ByteBuf)msg;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[returnMsg.readableBytes()];</span><br><span class="line">        returnMsg.readBytes(bytes);</span><br><span class="line">        System.out.println(<span class="string">"收到服务端返回的消息 ： "</span> + <span class="keyword">new</span> String(bytes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">        System.out.println(cause.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：<br><img src="https://img-blog.csdnimg.cn/20190308135541709.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019030813560014.png" alt="在这里插入图片描述"></p><p>博客中案例代码：<a href="https://download.csdn.net/download/qq_22871607/11072379" target="_blank" rel="noopener">https://download.csdn.net/download/qq_22871607/11072379</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty网络编程一：NIO</title>
      <link href="/2019/05/12/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%80%EF%BC%9ANIO/"/>
      <url>/2019/05/12/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%80%EF%BC%9ANIO/</url>
      
        <content type="html"><![CDATA[<p>写这些东西的原因，因为本人14年毕业，从事工作也有几年了，中间关于书，一直看了很多，有的甚至看过很多遍，但是总是觉得自己没有熟透一门技术，所以在学习使用技术之余，把自己所学的东西记录下来，便于加深印象，提升自我！</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1 传统BIO socket通信2 NIO 编程</code></pre><h1 id="一：传统socket通信"><a href="#一：传统socket通信" class="headerlink" title="一：传统socket通信"></a>一：传统socket通信</h1><p>在NIO编程没出来之前，java使用的socket编程时<br>socket 服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldSocketServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            Socket socket = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> OldSocketServerHandler(socket)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭服务端..."</span>);</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> OldSocketServer().start(<span class="number">8090</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的handler处理：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OldSocketServerHandler</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OldSocketServerHandler</span>(<span class="params">Socket socket</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        BufferedReader <span class="keyword">in</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">in</span> = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">this</span>.socket.getInputStream()));</span><br><span class="line">            String body = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((body = <span class="keyword">in</span>.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">" 服务端收到消息 : "</span> + body);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">in</span> != <span class="literal">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">in</span>.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>socket客户端：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OldSocketClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span>(<span class="params">String ip, <span class="keyword">int</span> port</span>) throws IOException</span> &#123;</span><br><span class="line">        Socket socket = <span class="literal">null</span>;</span><br><span class="line">        PrintWriter <span class="keyword">out</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(ip, port);</span><br><span class="line">            <span class="keyword">out</span> = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">out</span>.write(<span class="string">"this is socket client to server msg."</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">out</span> !=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">out</span>.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws IOException</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> OldSocketClient().connect(<span class="string">"localhost"</span>,<span class="number">8090</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面简单的一个socket通信问题，可以找出几个问题：<br>    <strong>问题1</strong>. 对于上面的服务端，当每接一个客户端请求，服务端必须new一个线程处理新的请求，对于java这种线程资源非常珍        贵的语言中，这种设计显示是有问题的。<br>    <strong>问题2</strong>：对于IO数据的读取上，对于InputStream输入流，当对socket的输入流进行读取操作的时候，线程会一直阻塞，直到读取到数据，或数据读取完毕，又或者发生空指针或I/O异常时。  同样输出流输出数据，OutputStream输出流会把所有的数据全部发送出去或者发生异常才会停止阻塞。显然，同步阻塞这种设计是十分浪费系统资源的。</p><h1 id="二：nio编程"><a href="#二：nio编程" class="headerlink" title="二：nio编程"></a>二：nio编程</h1><p>NIO是JDK1.4引入的，通过快的形式处理数据。NIO常用的几个概念：</p><p>1、Buffer(缓冲区)<br>    在传统的面向流的I/O中，数据是直接写入或读取到流对象中的，而在NIO中，所有的数据都是用缓冲区来处理的。缓冲区实质上就是一个数组，通过定义数据的结构，是的缓冲区能被重复利用。<br>NIO定义的Buffer的继承关系图：<br><img src="https://img-blog.csdnimg.cn/20190305194810844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyODcxNjA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>缓冲区定义四个属性来提供关于其所包含的数据元素的信息：<br>        1).容量 （ Capacity ）<br>        缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能 被改变。<br>        2).上界 （ Limit ）<br>        缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。<br>        3).位置 （ Position ）<br>        下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。<br>        4).标记 （ Mark ）<br>        一个备忘位置。调用 mark( )来设定 mark = postion。调用 reset( )设定 position = mark。标记在设定前是未定义的    (undefined)。 这四个属性之间总是遵循以下关系：<br>         0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity<br>新初始化的Buffer图：<br><img src="https://img-blog.csdnimg.cn/20190305194746165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyODcxNjA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2、通道Channel<br>    Channel是一个通道，是全双工的，就像是自来水管一样，网络数据通过Channel读取和写入。与流IO的不同之处在意，流IO只能进行读InputStream 或者写OutputStream, 而Channel可读可写。<br>Channel继承关系类图如下，主要有：ServerSocketChannel, SocketChannel, DatagramChannel<br><img src="https://img-blog.csdnimg.cn/20190305194653812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyODcxNjA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>3、多路复用器Selector<br>    多路复用器Selector提供选择已经就绪的任务的能力。selector会不断的轮询注册在其上的Channel, 如果某个Channel发生读或者写事件，则这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey获取就绪Channel的集合，进行后续的I/O操作。<br>    在JDK中selector使用了epoll()来实现select, 故此没有轮询Channel数量限制。</p><p>一个NIO的案例：<br>    服务端代码：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class NioServer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer readBuf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> start(<span class="built_in">int</span> port) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 1、打开ServerSocketChannel,用于监听客户端连接，是所有客户端连接的父管道</span></span><br><span class="line">            serverSocketChannel = ServerSocketChannel.<span class="built_in">open</span>();</span><br><span class="line">            <span class="comment">// 2、绑定监听端口，设置连接为非阻塞模式</span></span><br><span class="line">            serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 3、创建Reactor线程，创建多路复用器并启动线程</span></span><br><span class="line">            Selector selector = Selector.<span class="built_in">open</span>();</span><br><span class="line">            <span class="comment">// 4、将ServerSocketChannel注册到Reactor线程的多路复用器Selector上，监听ACCEPT事件</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">" 服务端开始工作....................."</span>);</span><br><span class="line">            run(selector);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(serverSocketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                serverSocketChannel.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> run(Selector selector) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.让多路复用器开始监听</span></span><br><span class="line">                selector.select();</span><br><span class="line">                <span class="comment">//2.返回多路复用器已经选择的结果集</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span>(keys.hasNext())&#123;</span><br><span class="line">                    SelectionKey <span class="built_in">key</span> = keys.next();</span><br><span class="line">                    keys.remove();</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">key</span>.isValid())&#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">key</span>.isConnectable())&#123;</span><br><span class="line">                            System.out.<span class="built_in">println</span>(<span class="string">"connectable...."</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">key</span>.isWritable())&#123;</span><br><span class="line">                            System.out.<span class="built_in">println</span>(<span class="string">"writable........."</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">key</span>.isAcceptable())&#123;</span><br><span class="line">                            System.out.<span class="built_in">println</span>(<span class="string">"acceptable...."</span>);</span><br><span class="line">                            accept(<span class="built_in">key</span>,selector);<span class="comment">//这里的key就是服务器端的Channel的key</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">key</span>.isReadable())&#123;</span><br><span class="line">                            System.out.<span class="built_in">println</span>(<span class="string">"readable...."</span>);</span><br><span class="line">                            read(<span class="built_in">key</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> read(SelectionKey <span class="built_in">key</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 清空旧的缓冲区</span></span><br><span class="line">            readBuf.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">//2.获取之前注册的socket通道对象</span></span><br><span class="line">            SocketChannel sc = (SocketChannel) <span class="built_in">key</span>.channel();</span><br><span class="line">            <span class="comment">//3.读取数据</span></span><br><span class="line">            <span class="built_in">int</span> count = sc.read(readBuf);</span><br><span class="line">            <span class="comment">//4.如果没有数据</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">key</span>.channel().close();</span><br><span class="line">                <span class="built_in">key</span>.cancel();</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"已无可读数据"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.有数据则进行读取，读取之前需要进行复位方法（把position和limit进行复位）</span></span><br><span class="line">            readBuf.flip();</span><br><span class="line">            <span class="comment">//6.根据缓冲区的数据长度创建相应大小的byte数组，接收缓冲区的数据</span></span><br><span class="line">            <span class="built_in">byte</span>[] bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[readBuf.remaining()];</span><br><span class="line">            <span class="comment">//7.接收缓冲区数据</span></span><br><span class="line">            readBuf.<span class="built_in">get</span>(bytes);</span><br><span class="line">            <span class="comment">//8.打印结果</span></span><br><span class="line">            <span class="keyword">String</span> body = <span class="keyword">new</span> <span class="keyword">String</span>(bytes).<span class="built_in">trim</span>();</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"Server: "</span> + body);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> accept(SelectionKey <span class="built_in">key</span>, Selector selector) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取服务端通道</span></span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) <span class="built_in">key</span>.channel();</span><br><span class="line">            <span class="comment">//2.执行客户端Channel的阻塞方法</span></span><br><span class="line">            SocketChannel sc = ssc.accept();</span><br><span class="line">            <span class="comment">//3.设置阻塞模式</span></span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//4.注册到多路复用器上，并设置读取标识</span></span><br><span class="line">            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">new</span> NioServer().start(<span class="number">8090</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>客户端代码：</code></pre><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class NioClient &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        SocketChannel sc = null;</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开通道</span></span><br><span class="line">            sc = SocketChannel.<span class="built_in">open</span>();</span><br><span class="line">            <span class="comment">//进行连接</span></span><br><span class="line">            sc.<span class="built_in">connect</span>(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8090</span>));</span><br><span class="line">            <span class="comment">//把数据放到缓冲区</span></span><br><span class="line">            buf.<span class="built_in">put</span>(<span class="string">"fangyouyun"</span>.getBytes());</span><br><span class="line">            <span class="comment">//复位</span></span><br><span class="line">            buf.flip();</span><br><span class="line">            <span class="comment">//写出数据</span></span><br><span class="line">            sc.<span class="built_in">write</span>(buf);</span><br><span class="line">            <span class="comment">//清空缓冲区数据</span></span><br><span class="line">            buf.<span class="built_in">clear</span>();</span><br><span class="line">        &#125; <span class="built_in">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="built_in">try</span> &#123;</span><br><span class="line">                sc.<span class="built_in">close</span>();</span><br><span class="line">            &#125; <span class="built_in">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：NIO以多路复用的设计方式，以及Buffer缓冲区的设计，都使得性能得到很大的提升，但是API太复杂了，所以选择Netty，因为Netty是基于NIO再次封装，便于开发。</p><p>博客中案例代码：<a href="https://download.csdn.net/download/qq_22871607/11072379" target="_blank" rel="noopener">https://download.csdn.net/download/qq_22871607/11072379</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

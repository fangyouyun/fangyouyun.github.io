{"meta":{"title":"方友运の博客","subtitle":"记录学习的技能和遇到的问题！","description":"做自己爱做的事，爱自己在做的事！","author":"方友运","url":"http://fangyouyun.github.io","root":"/"},"pages":[{"title":"技术资料","date":"2019-05-18T09:29:25.000Z","updated":"2019-05-19T00:36:50.994Z","comments":true,"path":"read/index.html","permalink":"http://fangyouyun.github.io/read/index.html","excerpt":"","text":"JAVA相关技术资料Java并发编程实战 : 链接：https://pan.baidu.com/s/1o56U_5j4Jf7tcRwiSizuXA 提取码：oeqqJava NIO(中文版) : 链接：https://pan.baidu.com/s/1QwMUPSUM6wDhJq50yBfyHw 提取码：ivgbJava并发编程的艺术 : 链接：https://pan.baidu.com/s/1itn1pN7zbAxOBQH2X-lIFQ 提取码：p5qiNetty权威指南 ： 链接：https://pan.baidu.com/s/1CJTLMs5F15sZCS721jxVqQ 提取码：vd9c深入理解Java虚拟机 ： 链接：https://pan.baidu.com/s/1vV5u45IxyDleZlq-OTWG7g 提取码：amgtSPRING技术内幕(高清版) : 链接：https://pan.baidu.com/s/1bmuoQjkyQS-qXGJwmXpgjQ 提取码：9n5ySpring Cloud微服务实战 ： 链接：https://pan.baidu.com/s/1DICHxVP1sE8NCQQJT_Xs7g 提取码：9lfz Python相关技术资料深入 Python 3 中文版 : 链接：https://pan.baidu.com/s/1PIdBw_4LFmSJbYXg75_LMA 提取码：uq3cPython学习手册(第4版) : 链接：https://pan.baidu.com/s/1e5IisbSmTQ1n-rA1cdW0Dg 提取码：8ny3Python核心编程(第二版) ： 链接：https://pan.baidu.com/s/1Vs05A3M343x1-GKPQ7zhMA 提取码：a8z2Python.Cookbook(第2版) ： 链接：https://pan.baidu.com/s/1TRXTSRbaN_OSjl3MjT0DFg 提取码：c49dFlaskWeb开发：基于Python的Web应用开发实战 ： 链接：https://pan.baidu.com/s/10E4qBTVdsGPqh7ez9UJtHw 提取码：3f2p 大数据相关技术资料linux相关Linux命令行与shell脚本编程大全.第3版 ： 链接：https://pan.baidu.com/s/12dMcNY671oEbBR2hs7QDpw 提取码：dn4u高级Bash脚本编程指南 ： 链接：https://pan.baidu.com/s/1gFKDraQh5_Z_RzkZGnlr_Q 提取码：oj9y TCP-IP协议TCP-IP详解卷1：协议 ： 链接：https://pan.baidu.com/s/1sZS973y7hceYWPP3V8ZvDw 提取码：jr07TCP-IP详解卷2：实现 : 链接：https://pan.baidu.com/s/16UKSgQ3TH0p53U6GxFiF6g 提取码：5r8tTCP-IP详解卷3：TCP事务协议 ： 链接：https://pan.baidu.com/s/1AnoXdZBGCPiXkkQxLd9MPA 提取码：bwyr 数据库MySQL高性能书籍_第3版（中文）： 链接：https://pan.baidu.com/s/1KbyMHEqFSXp34OtSw0r8MQ 提取码：nmi6MySQL技术内幕(第4版) : 链接：https://pan.baidu.com/s/1NnHltWSDkAyNyPs_Ifw53g 提取码：5t7i"},{"title":"博主自述","date":"2019-05-18T09:21:16.000Z","updated":"2019-05-18T09:24:40.993Z","comments":true,"path":"about/index.html","permalink":"http://fangyouyun.github.io/about/index.html","excerpt":"","text":"关于我91年生，14年毕业，屌丝程序员一枚 联系邮箱：fyyxj0812@126.com 关于本站开通于2019年65月1日，问题还很多，仍在不断完善中。本站所有文章除非特别说明均属原创，转载需保留署名和原文链接。 麻雀虽小，五脏俱全，本站目前已实现的功能有：图片粘贴上传、markdown、pdf自动下载、基于lucene的索引搜索、站点地图自动生成、评论留言系统、QQ微博一键登录、邮件提醒、目录导航自动生成、滚动监听、伪静态、移动端适配、图片懒加载、网址收藏(仅本人可见)、网页自动截图、html转markdown、札记功能(仅本人可见)、代码在线运行、自动化构建、多级文章目录、云文件夹管理、泛域名支持、一键转发至博客园、草稿箱功能，等等。 本站所有博客纯属个人笔记，错误、描述不到位、理解片面等等情况在所难免，如有不正确的地方欢迎评论中指正，我会及时更正。因为博客建立的太晚，很多以前写在各个角落的笔记、博客被我重新整理发表在这里，所以你会看到很多很基础很入门的文章。"}],"posts":[{"title":"Netty网络编程二：Netty概述以及入门案例","slug":"Netty网络编程二：Netty概述以及入门案例","date":"2019-05-12T02:37:37.000Z","updated":"2019-05-12T02:37:55.055Z","comments":true,"path":"2019/05/12/Netty网络编程二：Netty概述以及入门案例/","link":"","permalink":"http://fangyouyun.github.io/2019/05/12/Netty网络编程二：Netty概述以及入门案例/","excerpt":"","text":"本人写的Netty相关文章，全部基于版本4.1.33.Final 目录1、概述 2、入门案例一：概述虽然原生的java给我们提供了非常强大NIO的功能，但是由于使用上的，众多网络编程上的问题，任然需要开发者自己开发维护，因为选择Netty这种基于原生NIO进行开发的框架来助于我们的开发。 二：入门案例学任何框架都是从入门案例，netty也不例外，先搭建一个简单的服务端，客户端来理解Netty的便捷性。 需求：客户端连接服务端后，给服务端发送一条消息，服务端收到消息后，给客户端发送一条消息 服务端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class NettyServer &#123; private int port; public NettyServer(int port)&#123; this.port = port; &#125; public void start()&#123; // boss 是处理客户端连接的线程池 // worker 是处理从客户端连接转发过来的IO数据的读写线程池 NioEventLoopGroup boss = new NioEventLoopGroup(); NioEventLoopGroup worker = new NioEventLoopGroup(); try&#123; // ServerBootstrap 对外一个便利创建服务端，Builder建造者设计模式 ServerBootstrap sb = new ServerBootstrap(); // 绑定线程池 sb.group(boss,worker) // 绑定channel 服务端绑定NioServerSocketChannel,此实现jdk的ServerSocketChannel .channel(NioServerSocketChannel.class) // 绑定服务端相关参数，可添加绑定多个参数 .option(ChannelOption.SO_BACKLOG, 1024) //指定此套接口排队的最大连接个数 // IO事件处理类，主要处理IO事件的读写 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); // 添加 pipeline.addLast(new NettyServerHandler()); &#125; &#125;); // 绑定端口，同步等待成功 ChannelFuture cf = sb.bind(port).sync(); System.out.println(\"服务已启动.................监听端口：\" + port); // 等待服务器监听端口关闭 cf.channel().closeFuture().sync(); &#125;catch (Exception e)&#123; // 优雅关闭线程资源 boss.shutdownGracefully(); worker.shutdownGracefully(); &#125; &#125; public static void main(String[] args) &#123; NettyServer nettyServer = new NettyServer(9090); nettyServer.start(); &#125;&#125; handler处理器： 1234567891011121314151617181920212223242526272829303132333435363738public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf byteBuf = (ByteBuf) msg; byte[] buf = new byte[byteBuf.readableBytes()]; byteBuf.readBytes(buf); String str = new String(buf, \"utf-8\"); System.out.println(\"收到信息 ： \" + str); long currentTimeMillis = System.currentTimeMillis(); ByteBuf writeBuf = Unpooled.copiedBuffer((\"服务端发送的消息 ： \" + currentTimeMillis).getBytes()); ctx.write(writeBuf); &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; /** * 注意：此flush()方法是将消息发送队列中的消息写入到SocketChannel中发送给对方。 * 从性能角度考虑，为了防止频繁地唤醒Selector进行消息发送，Netty的write()方法并不直接将消息写入SocketChannel中， * 调用write()方法只是把待发送的消息放到发送缓冲数组中，再通过调用flush()方法，将发送缓冲区中的消息全部写到SocketChannel中 */ System.out.println(\"channelReadComplete............\"); ctx.flush(); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; System.out.println(\"消息异常.....exceptionCaught \"); // 当发送异常时，关闭ctx，是否和ctx相关联的句柄等资源 ctx.close(); &#125; @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; System.out.println(\"用户事件触发.... userEventTriggered\"); super.userEventTriggered(ctx, evt); &#125;&#125; 客户端代码： 12345678910111213141516171819202122232425public class NettyClient &#123; public static void main(String[] args) throws InterruptedException &#123; NioEventLoopGroup group = new NioEventLoopGroup(); try&#123; Bootstrap b = new Bootstrap(); b.group(group).channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY,true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new NettyClientHandler()); &#125; &#125;); // 异步连接服务端 ChannelFuture f = b.connect(new InetSocketAddress(9090)).sync(); // 等待关闭 f.channel().closeFuture().sync(); &#125;finally &#123; //优雅退出，是否线程池资源 group.shutdownGracefully(); &#125; &#125;&#125; 客户端handler处理器: 12345678910111213141516171819202122232425public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; // 当客户端与服务端链路建立成功后调用此方法 System.out.println(\"channelActive...\"); ByteBuf message = Unpooled.copiedBuffer(\"fangyouyun client msg\".getBytes()); ctx.writeAndFlush(message); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; System.out.println(\"channelRead......\"); ByteBuf returnMsg = (ByteBuf)msg; byte[] bytes = new byte[returnMsg.readableBytes()]; returnMsg.readBytes(bytes); System.out.println(\"收到服务端返回的消息 ： \" + new String(bytes)); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); System.out.println(cause.getMessage()); &#125;&#125; 测试结果： 博客中案例代码：https://download.csdn.net/download/qq_22871607/11072379","categories":[],"tags":[]},{"title":"Netty网络编程一：NIO","slug":"Netty网络编程一：NIO","date":"2019-05-12T02:19:21.000Z","updated":"2019-05-12T02:36:25.155Z","comments":true,"path":"2019/05/12/Netty网络编程一：NIO/","link":"","permalink":"http://fangyouyun.github.io/2019/05/12/Netty网络编程一：NIO/","excerpt":"","text":"写这些东西的原因，因为本人14年毕业，从事工作也有几年了，中间关于书，一直看了很多，有的甚至看过很多遍，但是总是觉得自己没有熟透一门技术，所以在学习使用技术之余，把自己所学的东西记录下来，便于加深印象，提升自我！ 目录1 传统BIO socket通信 2 NIO 编程一：传统socket通信在NIO编程没出来之前，java使用的socket编程时socket 服务端： 123456789101112131415161718192021public class OldSocketServer &#123; private void start(int port) throws IOException &#123; ServerSocket serverSocket = null; try &#123; serverSocket = new ServerSocket(port); Socket socket = null; while (true)&#123; socket = serverSocket.accept(); new Thread(new OldSocketServerHandler(socket)).start(); &#125; &#125;finally &#123; System.out.println(\"关闭服务端...\"); serverSocket.close(); &#125; &#125; public static void main(String[] args) throws IOException &#123; new OldSocketServer().start(8090); &#125;&#125; 对应的handler处理： 123456789101112131415161718192021222324252627282930313233343536public class OldSocketServerHandler implements Runnable &#123; private Socket socket; public OldSocketServerHandler(Socket socket) &#123; this.socket = socket; &#125; public void run() &#123; BufferedReader in = null; try &#123; in = new BufferedReader(new InputStreamReader(this.socket.getInputStream())); String body = null; while ((body = in.readLine())!=null)&#123; System.out.println(\" 服务端收到消息 : \" + body); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(socket != null)&#123; try &#123; if(in != null)&#123; in.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; socket客户端： 12345678910111213141516171819202122232425public class OldSocketClient &#123; private void connect(String ip, int port) throws IOException &#123; Socket socket = null; PrintWriter out = null; try &#123; socket = new Socket(ip, port); out = new PrintWriter(socket.getOutputStream(), true); out.write(\"this is socket client to server msg.\"); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; if(out !=null)&#123; out.close(); &#125; if(socket != null)&#123; socket.close(); &#125; &#125; &#125; public static void main(String[] args) throws IOException &#123; new OldSocketClient().connect(\"localhost\",8090); &#125;&#125; 通过上面简单的一个socket通信问题，可以找出几个问题： 问题1. 对于上面的服务端，当每接一个客户端请求，服务端必须new一个线程处理新的请求，对于java这种线程资源非常珍 贵的语言中，这种设计显示是有问题的。 问题2：对于IO数据的读取上，对于InputStream输入流，当对socket的输入流进行读取操作的时候，线程会一直阻塞，直到读取到数据，或数据读取完毕，又或者发生空指针或I/O异常时。 同样输出流输出数据，OutputStream输出流会把所有的数据全部发送出去或者发生异常才会停止阻塞。显然，同步阻塞这种设计是十分浪费系统资源的。 二：nio编程NIO是JDK1.4引入的，通过快的形式处理数据。NIO常用的几个概念： 1、Buffer(缓冲区) 在传统的面向流的I/O中，数据是直接写入或读取到流对象中的，而在NIO中，所有的数据都是用缓冲区来处理的。缓冲区实质上就是一个数组，通过定义数据的结构，是的缓冲区能被重复利用。NIO定义的Buffer的继承关系图： 缓冲区定义四个属性来提供关于其所包含的数据元素的信息： 1).容量 （ Capacity ） 缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能 被改变。 2).上界 （ Limit ） 缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。 3).位置 （ Position ） 下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。 4).标记 （ Mark ） 一个备忘位置。调用 mark( )来设定 mark = postion。调用 reset( )设定 position = mark。标记在设定前是未定义的 (undefined)。 这四个属性之间总是遵循以下关系： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity新初始化的Buffer图： 2、通道Channel Channel是一个通道，是全双工的，就像是自来水管一样，网络数据通过Channel读取和写入。与流IO的不同之处在意，流IO只能进行读InputStream 或者写OutputStream, 而Channel可读可写。Channel继承关系类图如下，主要有：ServerSocketChannel, SocketChannel, DatagramChannel 3、多路复用器Selector 多路复用器Selector提供选择已经就绪的任务的能力。selector会不断的轮询注册在其上的Channel, 如果某个Channel发生读或者写事件，则这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey获取就绪Channel的集合，进行后续的I/O操作。 在JDK中selector使用了epoll()来实现select, 故此没有轮询Channel数量限制。 一个NIO的案例： 服务端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class NioServer &#123; private ByteBuffer readBuf = ByteBuffer.allocate(1024); private void start(int port) throws IOException &#123; ServerSocketChannel serverSocketChannel = null; try&#123; // 1、打开ServerSocketChannel,用于监听客户端连接，是所有客户端连接的父管道 serverSocketChannel = ServerSocketChannel.open(); // 2、绑定监听端口，设置连接为非阻塞模式 serverSocketChannel.socket().bind(new InetSocketAddress(port)); serverSocketChannel.configureBlocking(false); // 3、创建Reactor线程，创建多路复用器并启动线程 Selector selector = Selector.open(); // 4、将ServerSocketChannel注册到Reactor线程的多路复用器Selector上，监听ACCEPT事件 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); System.out.println(\" 服务端开始工作.....................\"); run(selector); &#125;finally &#123; if(serverSocketChannel!=null)&#123; serverSocketChannel.close(); &#125; &#125; &#125; private void run(Selector selector) &#123; while(true)&#123; try &#123; //1.让多路复用器开始监听 selector.select(); //2.返回多路复用器已经选择的结果集 Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator(); while(keys.hasNext())&#123; SelectionKey key = keys.next(); keys.remove(); if(key.isValid())&#123; if(key.isConnectable())&#123; System.out.println(\"connectable....\"); &#125; if(key.isWritable())&#123; System.out.println(\"writable.........\"); &#125; if(key.isAcceptable())&#123; System.out.println(\"acceptable....\"); accept(key,selector);//这里的key就是服务器端的Channel的key &#125; if(key.isReadable())&#123; System.out.println(\"readable....\"); read(key); &#125; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void read(SelectionKey key) &#123; try &#123; // 1. 清空旧的缓冲区 readBuf.clear(); //2.获取之前注册的socket通道对象 SocketChannel sc = (SocketChannel) key.channel(); //3.读取数据 int count = sc.read(readBuf); //4.如果没有数据 if(count == -1)&#123; key.channel().close(); key.cancel(); System.out.println(\"已无可读数据\"); return; &#125; //5.有数据则进行读取，读取之前需要进行复位方法（把position和limit进行复位） readBuf.flip(); //6.根据缓冲区的数据长度创建相应大小的byte数组，接收缓冲区的数据 byte[] bytes = new byte[readBuf.remaining()]; //7.接收缓冲区数据 readBuf.get(bytes); //8.打印结果 String body = new String(bytes).trim(); System.out.println(\"Server: \" + body); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void accept(SelectionKey key, Selector selector) &#123; try &#123; //1.获取服务端通道 ServerSocketChannel ssc = (ServerSocketChannel) key.channel(); //2.执行客户端Channel的阻塞方法 SocketChannel sc = ssc.accept(); //3.设置阻塞模式 sc.configureBlocking(false); //4.注册到多路复用器上，并设置读取标识 sc.register(selector, SelectionKey.OP_READ); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws IOException &#123; new NioServer().start(8090); &#125;&#125; 客户端代码：1234567891011121314151617181920212223242526272829public class NioClient &#123; public static void main(String[] args) &#123; SocketChannel sc = null; ByteBuffer buf = ByteBuffer.allocate(1024); try &#123; //打开通道 sc = SocketChannel.open(); //进行连接 sc.connect(new InetSocketAddress(\"127.0.0.1\", 8090)); //把数据放到缓冲区 buf.put(\"fangyouyun\".getBytes()); //复位 buf.flip(); //写出数据 sc.write(buf); //清空缓冲区数据 buf.clear(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; sc.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 总结：NIO以多路复用的设计方式，以及Buffer缓冲区的设计，都使得性能得到很大的提升，但是API太复杂了，所以选择Netty，因为Netty是基于NIO再次封装，便于开发。 博客中案例代码：https://download.csdn.net/download/qq_22871607/11072379","categories":[],"tags":[]}]}